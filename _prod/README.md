## FXA Kubernetes Production Deployment

This folder contains yaml files that can be used to build a kubernetes production deployment in which each of the fxa servers is deployed to its own pod(s) and every server talks to every other server using a kubernetes service.

### Table of Contents

[Intro to Kubernetes](#intro-kubernetes)\
[Setup & Install](#setup)\
[Docker files](#dependencies)\
[Yaml config files](#yaml-config)\
[Environment Variables](#env-vars)\
[Secrets](#secrets)\
[Mysql](#mysql)\
[Deploying](#deploying)\
[Kubernetes Shortcuts](#shortcuts)\
[Testing](#testing)\
[Possible Problems](#possible-problems)\
[Remaining work](#remaining)

---

### Intro to Kubernetes
The FXA _dev environment uses a combination of pm2 and docker to run all the servers and database on a single machine.  This is not ideal for production.  In production we need to:
1. Deploy different servers to different machines/containers.
2. Monitor the traffic load on the set of servers.
3. Horizontally scale the various servers based on traffic load.
4. Have server/type redundancy by deploying across multiple containers.

Kubernetes allows us to achieve all of these goals.  With Kubernetes we can structure our code so that:
1. Each different type of server will run in its own Kubernetes "Deployment".  So for example there is a deployment for fxa-content-server and another one for the fxa-profile-server etc.
2. The deployment creates one or more "pods" for each server.  These "pods" correspond to docker containers.
3. For each type of server there is also a Kubernetes "service".  The "service" provides an internal dns name which acts as a load balancer to route traffic to all the pods that have been created by that server's deployment.

### Setup & Install
To work with a Kubernetes cluster you will need to install the kubectl command line tool.  To install on Ubuntu, please use the following steps:

```
sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl
sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
sudo apt-get update
sudo apt-get install -y kubectl
```

We also build a docker image.  For that you will need to install docker on your dev machine:

```
sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"
sudo apt update
apt-cache policy docker-ce
sudo apt install docker-ce
```

### Docker files
Since all the servers (except the sync server) are in the same git repo and because many of their dependancies are the same, we build a single docker image that every server (except the sync server) uses from the file Dockerfile.fxa.

There is a command line tool called buildDocker.sh that does the build. Usage: buildDocker version [userName]

In addition to building the docker file it also tags the file so that you can publish it to an account at hub.docker.com with a specified username (defaults to peteroffthestrip). The Kubernetes cluster will need to pull the docker image from here in order to create pods.

The steps to publish the image are as follows:
1. Create an account at hub.docker.com
2. On your command line run sudo docker login  --username bob --password mypass
3. sudo docker push username/fxa

#### Other docker files
The Mozilla sync server, redis server and memcached server all use docker images that are pulled from the public domain.

### Yaml config files
We need to configure 5 different kinds of Kubernetes objects:
1. Deployments - these create pods/containers that run our code
2. Services - these create internal load balanced endpoints for our deployments to talk to each other.
3. ConfigMaps - these create list of environment variables that our servers use to configure themselves within each pod/container.
4. Secrets - similar to ConfigMaps only used for passwords and all content is encoded.
5. Ingress (not made yet) - These provide external load balanced endpoints for our set of servers.

### Environment Variables
Environment variables are stored in ConfigMaps for each server type.  Most of these lists have been generated by looking at the configuration code for each server and figuring out what environment variables are used to override the default configurations.

One special environment variable "server" is used by our docker file (and specifically by the launcher.sh that it runs when it starts up) to determine which of our servers to run in the container.  Valid values include (fxa-profile-server, fxa-payments-server, fxa-payments-server-static, fxa-payments-server-worker, fxa-graphql-api, fxa-content-server, fxa-customs-server, fxa-auth-server, fxa-auth-db-mysql, browserid-verifier, 123done and 321done).
### Secrets
Secrets files are where you store passwords and keys for use in Kubernetes Deployments.  We currently have two:
1. mysql-secret.yaml - see next section
2. keys-secret.yaml - a place to keep keys used by the various servers.  Currently have only put the sync servers key in but others have keys that are current in their ConfigMaps which should be moved into here for security.

The values in the secret values are base64 encoded.  This can be done as follows:
```
echo -n "My Password" | base64
```
### Mysql
Rather than deploying mysql within our Kubernetes cluster it is recommended that you use an external cloud-based clustered database server such as Amazon RDS.  Once this is done and you have the credentials for that server, you will need to add them to the mysql-secret.yaml configuration file.
### Deploying
First you need to connect your local kubectl command line client with your remote Kubernetes cluster.  To do that you need to download your cluster configuration file and run this command:
```
cd && mkdir .kube
cd ~/.kube && kubectl --kubeconfig="clustername-kubeconfig.yaml" get nodes
```
Once this is done you can deploy each of our yaml configuration files using a single line.  You should launch the Secrets and root configuration file first (because many of the other objects depend on them:
```
kubectl apply -f mysql-secret.yaml
kubectl apply -f keys-secret.yaml
kubectl apply -f root-configmap.yaml
```
Next do the ConfigMap, Deployment and Service for fxa-auth-db-mysql:
```
kubectl apply -f fxa-auth-db-mysql.yaml
```
Note that when you apply a file it only relaunches the components in the file that have actually changed!

#### Kubernetes Shortcuts
Here are some handy kubectl commands that you can use to watch what your deployments are doing and to see their log files:
1. kubectl get all -- Show everything that has been deployed on the cluster
2. kubectl get pods -- Show all the pods that have been deployed
3. kubectl get services -- Show the services
4. kubectl delete deployment [deployment name] -- Delete the deployment and the pods associated with it
5. kubectl delete pod/[pod id] -- You can get the pod id from "get pods".  This will delete the pod (which will automatically be restarted if it is associated with an active deployment).
6. kubectl describe [service name] - Show the ports and ips of the service
7. kubectl describe pod/[pod id] - While launching, shows what it is doing and any errors that happen before the container itself is launched.
8. kubectl logs [pod id] - Shows the logging output generated by the pod.  (Generally from the stdout created by the app which the container runs on startup).
Deploying to the 
### Testing
After launching a deployment use "get pods" to get the pod id then use "describe pod/[pod id]" to make sure it is starting up ok.  Finally use "logs [pod id]" to make sure that the service isn't running into any errors.

"get pods" also gives you the overall status of all your pods, even without using "describe" or "logs".  For example, here we can see that all my servers except event-broker and mail-service are at least running (the container process has been run without crashing):
```
kubectl get pods
NAME                                         READY   STATUS             RESTARTS   AGE
123done-96bb7bf85-vgb5f                      1/1     Running            0          1d
321done-7fdb98bd6f-ckl7t                     1/1     Running            0          1d
fortress-874b5df9f-dpx6j                     1/1     Running            0          1d
fxa-auth-db-mysql-5d468b4fc6-cbvd7           1/1     Running            0          1d
fxa-auth-server-546c59b675-k5r7c             1/1     Running            240        6h
fxa-content-server-7b59fd789d-4j8pr          1/1     Running            33         6h
fxa-customs-server-7974f6cfb5-qt58d          1/1     Running            0          1d
fxa-event-broker-85d769968b-hvpnc            0/1     CrashLoopBackOff   784        6h
fxa-graphql-api-55d4f66b4d-m9zqz             1/1     Running            137        1d
fxa-mail-service-568d5c6949-2cqbp            0/1     CrashLoopBackOff   2702       1d
fxa-payments-server-5fb9cf7589-hg849         1/1     Running            2526       1d
fxa-profile-server-b977c7668-zklh9           1/1     Running            0          6h
fxa-profile-server-static-57b76ff855-zqkvb   1/1     Running            0          6h
fxa-profile-server-worker-6fbd775cf4-j6xz5   1/1     Running            0          6h
memcached-5c6bdb8754-8mmsp                   1/1     Running            0          6h
mozilla-sync-7d494df7-p958x                  1/1     Running            9          2d
redis-master-64f7c9fcbb-vk9kg                1/1     Running            0          8d
```
### Possible Problems
#### Non-parallelizable servers
We are making an assumption that all the fxa-servers are fully parralelizable so long as they have  common persistant data stores (mysql, redis, memcache).  Without an in-depth audit of the source code there is no way to know that for certain.
#### Unknown endpoints
Many of the servers have settings that refer to other server's url/port.  We have replaced these settings with references to the kubernetes services.  This works great if the purpose of the setting is for one server to talk to another.  It doesn't work if this link is actually being passed out to the end user for the client browser to request.  Each of the servers will have to be examined one at a time to see if they are operating correctly.
### Remaining work
#### Servers that don't run
The fxa-event-broker and the fxa-mail-service pods are not running at this time.  The errors in their logs need to be examined to figure out why.  Note that you can only use "kubectl logs" on a running pod, so to debug these servers that fail to run, launch the fxa-debug.yaml file.  It will create a debug pod with our fxa-docker image.  You can then connect to that pod using: 
```
kubectl exec -it pod_name bash
```
Once in you will need to examine the yaml file of the server that you want to try to run and use "export var=val" to initialize the environment variables that it needs to run.  When the environment variables (including the server) variable are run, you can then run ./launch.sh from the command line and see what it outputs before it dies.
#### Secret keys in the ConfigMaps
There are a few secret keys in ConfigMaps that should be base64ed and placed in keys-secret.yaml
#### Monitoring & Scaling
Kubernetes has a host of tools for monitoring the traffic on the servers and launching new pods within each deployment should the traffic spike too high.
#### DEVENV
This environment variable is set in the root config to either dev or prod but on further examination some of the servers use those values and others use "development" and "production".
#### StatsD Server
A couple of the server's configurations reference a "statsd" server.  This server can talk either on TCP or UDP.  The default ports used seem to indicate that the servers are using UDP.  We have created a StatsD deployment and service using UDP but it has not been tested at this time.